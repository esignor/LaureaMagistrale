\documentclass[10pt,a4paper]{book}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float} 
\begin{document}
\chapter{Introduzione}
Questo corso si occupa di presentare alcune tecniche avanzate dei moderni linguaggi di programmazione, con il fine di far imparare  a comprendere, ragionare e valutare.\\\\
I linguaggui di programmazione sono tantissimi (pi\`u di 703), alcuni parlano tra di loro, altri invece formano una torre di babele.\\
Non esiste un linguaggio migliore in assoluto, c'\`e invece il linguaggio pi\`u adatto a una tale situazione. Ecco che \`e importante saper valutare. Per poter scegliere un linguaggio \`e importante valutare alcuni fattori quali: efficienza, retrocompatibilit\`a, interoperabilit\`a (cooperare e scambiare informazioni), portabilit\`a, correttezza, produttivit\`a (velocit\`a di scrivere un primo prototipo rapidamente) e espressitivit\`a (capacit\`a di scrivere in modo chiaro le linee di codice).\\
Inoltre \`e importante, quando si sceglie un linguaggio, capire cosa si deve scrivere, un piccolo \textit{script} o un enorme base di dati per centinaia di programmatori e il tipo di programmatore che deve scirvere il linguaggio, esperto o principiante. Infatti se si costringe un programmatore a scrivere in un linguaggio a lui non gradito, lo stile del codice diventa innature, dove \`e pi\`u facile inseririvi del \textit{bug}.\\\\
Se si riesce a individuare un insieme di misurazione, si riesce a tradurre un linguaggio in numeri; ma attenzione misurare ha un significato diverso di valutare.\\
Si p\`o difatti cercare di misurare quale \`e il linguaggio di programmazione maggiormente in uso. Come si fa? Possono essere impiegate, per esempio, le ricerche sul \textit{Web} svolte dagli utenti per i linguaggi, oppure il numero di progetti presenti su GitHub. Tuttavia c'\`e da considerare che questi possono rappresentare anche altri indicatori, magari il fatto che si discuta di un linguaggio \`e sinonimo di incertezze, inoltre il mondo open-source pu\`o avere le sue preferenze di programmazione.\\
Vediamo ora due indici che misurano i linguaggi di programmazione:
\begin{itemize}
\item \textbf{TIOBE Index}: \`e un indice di seriet\`a che dichiara come sono stati calcolati gli indici. Su questa lista troviamo in ordine di apparizione:
\begin{itemize}
\item Python, linguaggio con popolarit\`a in crescita, perch\`e ha librerie gi\`a pronte come nel caso dell'AI, dei microcontrollori o dei sistemi \textit{embedded} (\textit{special purpose});
\item Objective-C, nato assieme al C. Apple ha costretto per una sua scelta interna aziendale i programmatori a utilizzare tale linguaggio. Dal 2014 ha, tuttavia, rilasciato un nuovo linguaggio Swift (Objective-C + \textit{feature}) che ha proclamato la morte di Objective-C.
\item Scratch, linguaggio a blocchi per l'apprendimento dell'informatica ai bambini delle elementari. Sta crescendo a supporto della didattica nelle scuole, tuttavia  \`e riservato a un dominio specifico.
\item COBOL, rimane in buona posizione perch\`e usato dalla banche;
\item Rust, linguaggio nuovo, che da un supporto efficace alla programmazione di sistema.
\end{itemize}
\item \textbf{IEEE Spectrum}, genera un buon \textit{ranking} e permette all'utente di modificare i pesi delle misurazioni. \`E specializzato su applicativo. Sulla lista troviamo in ordine di apparizione:
\begin{itemize}
\item Swift, che riespetto al caso precedente si trova molto pi\`u in alto rispetto a Objective-C;
\item Fortran, che \`e uno dei primo linguaggi sviluppati. Si presenta \textit{codebase legancy} (codice che non \`e pi\`u supportato dall'applicazione) e mantenuto per le applicazioni scientifiche.
\end{itemize}
\end{itemize}
\noindent
Per\`o non sempre per far ordine tra i linguaggi si pu\`o solo utilizzare una lista, difatti possono venire anche classificati: livello basso, medio e alto o in base ai linguaggi di programmazione. Si pu\`o anche produrre una tavola periodica dei linguaggi o  qualcosa di pi\`u divertente, come basandosi sui personaggi del Signore degli Anelli.\\\\
Esistono diversi paradigmi di programmazione:
\begin{itemize}
\item \textbf{Imperativi}: il programma \`e un insieme di istruzioni eseguite  che cambiano lo stato del programma stesso;
\item \textbf{Funzionali}: il programma \`e un insieme di funzioni matematiche da valutare, si evita il concetto di stato e dati modificabili;
\item \textbf{Orientati agli Oggetti}: il programma \`e un insieme di oggetti e azioni su questi oggetti;
\item \textbf{\textit{Event-Driven}}: il programma \`e un insieme di eventi scatenati dall'interazione con l'utente;
\item \textbf{Dichiarativi}: il programma \`e un insieme di regole (SQL, Prolog ..);
\item \textbf{Concorrenti}: il programma \`e un insieme di flussi concorrenti in esecuzione (segnali e messaggi inviati e ricevuti dai \textit{thread}) (Java, Ada, Go ..);
\item \textbf{Multiparadigma}: \textit{mix} dei paradigmi sopra enunciati. Alcuni esempi sono Ada e C++ (Imperativi e OO), Python (funzionale, OO, imperativo).
\end{itemize}
\noindent
Le tecniche per osservare questa giungala di linguaggio non \`e finito. Si pu\`o difatti creare uno storico con:
\begin{itemize}
\item Data di nascita dei vari linguaggi;
\item Con una \textit{Timeline}, in cui per ogni linguaggio vengono indicate anche le \textit{release}. Con presenza di intersezioni quando un linguaggio ne influenza un altro.
\end{itemize}
\noindent
Oppure con il punto di vista dell'utilizzatore, il programmatore, del linguaggio. In questo caso si fanno uso dei punti d'entrata:
\begin{itemize}
\item Programmazione con BASIC;
\item Programmazione a basso livello, si parte da asm;
\item Programmazione numerica/scientifica, si parte da R;
\item \textit{Scripting} di un programma e mondo \textit{Web}, si parte da sh.
\end{itemize}
\noindent
Ma le possibilit\`a non sono terminate. Si pu\`o misurare un linguaggio anche guardando la loro evoluzione, con la regola \textit{Darwiniana}.
La regola \textit{Darwiniana} dice che le speci non si sviluppano in modo lineare, ma a grafo. I linguaggi hanno fatto e fanno lo stesso. Si pu\`o per questo riutilizzare l'idea della linea del tempo, non con la data di nascita, ma i pi\`u popolari in ogni dato periodo. Tale tecnica permette di linearizzare i salti evolutivi.\\
Vediamo di seguito alcuni dei salti evolutivi che hanno visto i linguaggi responsabili.\\
Il primo salto evolutivo \`e degli anni '80 dove ogni caso ha il proprio PC. Questi sono anche gli anni dove nascono i paradigmi di programmazione (C, PASCAL, ..). Successivamente, negli anni '90, nascono i linguaggi a oggetti, prima solo in ambito accademico per poi traslare sulle industrie che necessitavano di un \textit{software} di grandi dimensioni e richiedevono un linguaggio in grado di organizzare il codice, affidabile, riusabile e economico. \`E in questo periodo che nascono gli IDE e arriva Intenet, il concetto di popolarit\`a e sicurezza (grazie a Java). Con l'entrata in scena di Java assume importanza anche il \textit{typing} statico, infatti rispetto al C++ offre una maggiore sicurezza. Con il proseguire degli anni i tipi iniziano a diventare verbosi, si cerca una maggiore produttivit\`a, nascono linguaggi come Ruby e Javascript e inizia la guerra ai tipi. Dal momento in cui i \textit{computer} diventano \textit{multicore}, dunque \textit{hardware} assume caratteristiche di concorrenza, si inizia a usare la programmazione concorrente, linguaggio esistente gi\`a da tempo.\\\\
Perch\`e la programmazione concorrente \`e difficile?
\begin{enumerate}
\item La concorrenza porta con se non determinismo, difatti ogni esecuzione porta un risultato diverso;
\item I linguaggi non sono pensati per essere concorrenti.
\end{enumerate}
\noindent
Quando si pensa a un algoritmo in pseudocodice poi c'\`e sempre la necessit\`a di tradurlo in un linguaggio. Esiste dunque la necessit\`a di ridurre questo \textit{gap}, per limitare i possibili \textit{bug} che si potrebbero creare. Esistono per farlo, alcuni modelli di concorrenza: multithread, message passing, reactive programming per la programmazine distribuita e GP-GPU che effettua \textit{parser} di dati.\\\\
Ai giorni d'oggi c'\`e la rinascita della programmazione funzionale (\textit{lambda}).\\
La programmazione imperativa \`e sequenziale temporale percui \`e difficile ottenerne parallelismo. Invece in quella funzionale esistono dei costrutti per aggreggare le funzioni, inteso come il comportamento. Va a mattoncini, riuscendo in questo modo a lavorare in parallelo. Un vantaggio del funzionale puro rispetto all'imperativo \`e che con causa \textit{side-effect}, dunque pu\`o venire usato prima e dopo nel tempo senza effetti collaterali.\\
Va reso noto come la OOP non sia per\`o esclusivamente imperativa, infatti esistono che la implementano linguaggi a oggetti funzionali.\\\\
Importante ai nostri giorni \`e anche la programmazione distribuita, dove tutto viene messo su \textit{cloud}, in remoto. In questo modo i linguaggi riescono a lavorare asincronamente, sono scalabili, elastici e resistenti al fallimento.\\\\
Dove stiamo andando? Verso la \textit{Data-Science}, strutture dati enormi, dove vi \`e la necessit\`a di algoritmi in grado di lavorarci.\\
Un esempio JAVA8 che e quasi un nuovo linguaggio rispetto a JAVA7.  In questa versione si sono introdutte strutture come passaggi di funzione con i \textit{parallel stream}, che permetto di lavorare su strutture dati enormi in parallelo. Tale cambiamento \`e stato indispensabile altrimenti JAVA sarebbe uscito dai giochi.\\\\
In conclusione quando un programmatore sceglie un linguaggio porta uno stile. Cosa si dice \`e influenzato dal come lo si dice.
\\\\\\
Alcune incoerenze presenti all'interno degli articoli :
\begin{itemize}
\item Goodbye, Object-Oriented Programming. C. Scalfani, Medium, July 2016.
\begin{itemize}
\item "Si perde tempo a creare gerarchie, sta bene solo sui libri."\\
Tuttavia quando si parla di \textit{inhertiance} non si tratta di classificare, difatti \`e solo un metodo che permette di pensare a contratti "si comporta come" (voglio ereditare certi comportamenti ed estenderli).
\item "Una classe viene riusata in un altro progetto."\\
Ma nella OOP la riusabilit\`a \	`e intesa nel medesimo progetto che negli anni deve essere mantenuto.
\item "Le interfaccie sono sufficienti a fare polimorifsmo".\\
Tuttavia va considerato che esistono diversi tipi di polimorfismo. In questo caso specifico si interpreta come \textit{subtyping} dunque le interfacce sono si sufficienti, ma esiste anche il \textit{parametric polymorfism} con \textit{template/generics}.
\end{itemize}
\item Object-Oriented Programming - The Trillion Dollar Disaster. Ilya Suzdalnitski, Medium, July 2019.
\begin{itemize}
\item "Complessit\`a del codice che ne esce".\\
Questo perch\`e \`e stato fatto uso dell'OOP con accessi concorrenti, ma esiste anche la OOP sequenziale. Invece quando vengono trattati i \textit{design pattern} esiste effettivamente un \textit{gap} tra quello che il linguaggio permette di scrivere e ci\`o che i \textit{pattern} offrono.
\item "La OOP nasce dall'accademia".\\
Non \`e vero \`e un linguaggio uscito proprio dall'accademia.
\end{itemize}
\end{itemize}
\noindent


\end{document}